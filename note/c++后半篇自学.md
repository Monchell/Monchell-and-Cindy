# c++ 后半篇自学
## 杂学
* 引用和指针具有多态性，对象没有
* 复用：二进制层面，编译单位的，一个文件测试完成后原封不动  
    拷贝不是复用，粘贴就是瞎贴
* ifelse，代码里bad smell，一般会违反开闭原则
* c++不按回车阻塞式接收一个字符
    ```c++
        char i=getch();
    ```
* 类的三个成员
    ```c++
        public:  void function();//和结构体一样
        protected:  int x,y;   //在类和派生类可见
        private:    int point ;//仅在类的函数中可见
    ```
* 子类的析构函数要写成虚函数
## 7.运算符重载
* 语法形式与规则
    ``` c++
        类型 类名::operator op(参数表)
        {
            //相对于类定义的操作
        }
    ```
    遵循原有的c++法则，比如不能a++b这样
* 主要用于一些和更加贴切数学的重载使用
* 一些系统默认重载
    * &重载为取地址
    * =重载为对对象数据成员的复制
* 一般重载用于友元函数和成员函数
    * 当运算符的左操作数是该类的一个对象时，重载为成员函数更多   
      左操作数通过this进入，右操作数成为指针
      ```c++
        Object op //前置
      ```
    * 当运算符的右操作数是该类的一个对象时，用友元函数，例如复数运算  
* 前后置的运算符区别,以自增为例
    * 前置
        ```c++
        A object 
        ++object//表达式
        object.operator++()//成员函数解释
        A & A::operator++()//成员函数原型
        operator++(object)//友元函数解释
        friend A & operator++(A &);//友元函数原型
        //引用类型是为了减少函数复制的开销
        ```     
    * 后置
        ```c++
        A object 
        object++//表达式
        object.operator++(0)//成员函数解释，0用于区分前后置
        A A::operator++(int)//成员函数原型,int作为固定格式即可
        operator++(object,0)//友元函数原型
        friend A operator++(A &,int);//友员函数原型
        //引用类型是为了减少函数复制的开销
        ```
    * 其他如[ ],(),=，<<,>>,!=这些自行参悟 有用再说
      比如可以用[ ]f访问向量组,  
      =来作特殊的复制构造函数  
      ()也可以实现一些骚操作
        ```c++    
         int & Vector::operator[](int i)const
         //&是为了合法
        ```
    * 类类型转换
        * 构造函数把int转换为A类型
        * int()的重载把A类型转换为int类型
            ```c++
             A::operator Type(){};
            ```

    

    
