# 设计模式 
##  复用性能 ! 管理稳定和变化！把跳动的小兔子关进笼子
## 1.设计模式简介
* 课程目标   
    * 理解松耦合设计思想  
    * 掌握面向对象设计原则
    * 握重构技法改善设计
    * 掌握GOF核心设计模式 
* 什么是设计模式  
每个模式不断重复的解决方案的核心，不要重复造轮子
* GOF设计模式  
    * 可复用面向对象软件的基础  
    * 目标：可复用
    * 手法：面向对象
* 面向对象谈起  
    * 底层思维：把握机器底层
        * 语言构造
        * 编译转换
        * 内存模型
        * 运行机制：把周围的世界抽象未程序代码
    * 抽象思维：管理代码复杂度
        * 面向对象
        * 组件封装
        * 设计模式
        * 架构模式
    * 程序员：联系现实需求和计算机
* 深入理解面向对象
    * 向下：深入理解面向对象三大机制，内部机制
        * 封装：隐藏内部实现
        * 继承：复用现有代码
        * 多态：改写对象行为
    * 向上： 把握面向对象对象机制带来的抽象意义  
    掌握什么是好多面向对象机智
* 抽象思维的背景，软件设计固有的复杂性
    * 根本原因：变化
        * 客户需求的变化
        * 技术平台的变化
        * 开发团队的变化
        * 市场环境的变化
    * 解决方法
        * 分解：分而治之
        * 抽象：抓住事物的本质特点，处理泛化和理想化的对象模型
            1. 父类指针指向子类对象
            2. 指针vector需要一个堆对象的指针
            3. 虚函数，多态调用的方法
## 2.面向对象设计原则
* 最大优势：抵御变化
* 面向对象
    * 底层：封装，继承，多态等
    * 抽象：
        * 隔离变化
        * 各司其职
        新增类不影响原类型的实现
    * 面向对象设计原则
        1. 依赖倒置原则（DIP）
            1. 高层模块（稳定）不应该依赖低层模块（变化）二者都应依赖于抽象（稳定）
            2. 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）
            3. 变化依赖稳定，不可相逆
            4. 关键点：提出抽象类（例程的shape）
        2. 开放封闭原则（OCP）
            1. 对拓展开放，对更改封闭（增加，而非修改）
            2. 类模块应该是可扩展的，但是不可修改
        3. 单一职责原则（SRP）
            1. 一个类应该仅有一个引起它变化的原因
            2. 变化的方向隐含着类的责任
        4. Liskov 替换原则（LSP）
            1. 子类必须能够替换他们的基类（IS-A）
            2. 继承表达类型抽象 
        5. 接口隔离原则（ISP）
            1. 不应该强迫客户程序依赖它们不用的方法（该protect就protect防止客户依赖性）
            2. 接口应该小而完备
        6. 优先使用对象阻合而不是类继承
            1. 类继承：白箱复用，对象组合：黑箱阻合，class A里面放一个class B这样
            2.  继承在某种程度上破坏了封装性
            3. 对象组合则只要求被组合对象有良好定义的接口
        7. 封装变化点 松耦合
            1. 使用封装来创建对象之间的分界层，让设计者可以在一侧变化的同时保持另一侧稳定
        8. 针对接口编程，而不是针对实现编程
            1. 不将变量类型声明为具体类，而是声明为接口
            2. 客户无需获知对象的具体类型，只需要指导对象具有的接口（抽象）
            3. 依赖接口而不依赖具体类型
            4. 和DIP相辅相成，只是角度不同
    * 接口标准化：产业昌盛的标志  
        1. 箭和弩的接口统一化，避免箭不对弩
        2. 木板字模的大小接口和活字的大小接口，分离
    * 设计原则->设计经验
        1. 设计习语 Design Idioms
            与特定语言相关的低层模式，技巧和惯用法
        2. 设计模式 Design Patterns
            类与接口，变化中的复用性问题
        3. 架构模式 Architectural Patterns
            系统划分，责任和写作关系
## 3.前言
* GOF-23 模式分类  
    *  从目的看来
        1. 创建型：解决对象创建工作
        2. 结构型：变化需求对对象结构的冲击
        3. 行为型：对各类直接的组合和交互的冲击  
    * 从范围，实现手段来看
        1. 类模式处理类和子类的静态关系，继承方案
        2. 对象模式处理对象间动态关系，组合关系
* 重构获得模式 Refactoring to Patterns
    * 好的面向对象设计：应对变化，提供复用
    * 软件特征：需求频繁变化  
        #### 要点：寻求并且在变化点处应用设计模式
    * 敏捷开发提倡的Refactoring to Patterns 是当前最好的
    * 重构：改善现有代码的设计
* 重构关键技法 ->转
    * 静态->动态
    * 早绑定（后调用前）->晚绑定（前调用后，callback函数）
    * 继承->组合
    * 编译时依赖->运行时依赖
    * 紧耦合->松耦合
* 组件协作模式
    * 背景：软件专业化分工划分出 
        1. 框架 framework和library
        2. 应用
    * 组件写作模式通过晚期绑定来实现框架与应用之间的松耦合
    * 二者写作的常用模式 
        1. Template Method 模板方法
        2. Strategy 策略模式
        3. Observer/Event 事件模式
        4. 其他模式也会有关系只是没有那么明显
## 4.模板方法Template method
* 组件协作模式
* 举个栗子：stm32的回调函数
* 动机
    * 每项任务有稳定的整体操作结构
    * 各个子步骤有改变的需求，而无法和任务的同时实现
    * 如何在确定稳定操作结构的前提下灵活应对各个滋补粥的变化或晚期实现需求
* 模式定义
    * 定义一个操作的骨架（稳定），而将一些步骤延迟变化到子类中。模板方法使得子类可以复用一个算法的结构，同时支持子类的变化（虚函数）
* 原则    
    * 前提条件：稳定的算法骨架结构，有变化的需求
    * 稳定中有变化而且互不干扰
    * 稳定的用非虚函数，变化时虚函数
    * 调用机制：虚函数，函数指针建立晚绑定机制
    * 稳定的步骤函数一般protected，单独调用没有意义
## 5.策略模式Strategy
* 组件协作模式
* 动机  
    1. 在软件构建过程种算法多种多样经常改变，如果都编码到对象种会使得对象异常复杂
* 例子：各个国家有各个国家的税法
* 模式定义  
    定义一系列算法，封装起来使得不同算法之间可以互相替换（变化）
* 结果  
    算法可以独立于他的现有发行版本程序（稳定）而变化（拓展，子类化）
* 要点总结  
    1. 为子类和组件提供一系列可重用的算法
    2. 提供除了ifelse，switch外的其他用法
        1. ifelse是一种分而治之的做法
        2. 可以开始考虑一下，一般可以使用抽象的做法解决
        3. ifelse，代码里bad smell
    3. Strategy对象如果没有实例变量，那么上下文可以共享同一个对象，节省对象开销
    4. 一个顺带的好处：代码具有良好的本地性，不同的方法分别封装，使用时调用，减小内存占用
## 6.观察者模式Observer/Event 非常的常用
* 组件协作模式
* 动机
    1. 为一些对象建立“通知依赖关系”，一个对象状态变化时**所有的对象**都会得到通知，一种**一对多**关系
* 例子：天气变化与仪器订阅
    * 直接在类里面加仪器数据传输，这是一个可能改变的实现细节
    * 粗浅方案：去找不同的仪器的基类
    * 观察者模式：用一个抽象的方式来表达通知，而不用一个具体的控件。因此使用一个仪器vector_list作为基类来作为媒介，通过**add**，**remove**来对不同的主题进行选择订阅，**update**的方式来进行更新，rm的官方information库的做法就是这样
    * c++不推荐多继承，但是推荐一种多继承的形式  
      一个主继承和其他的是接口或者基类
    * 要点总结
        1. 使用面向对象的抽象，Observer模式使得我们可以独立的改变目标和观察者，使得二者的依赖关系达到松耦合
        2. 目标发送通知时无需指定观察者，通知（可以写代通知信息作为参数）会自动传播
        3. 观察者自己决定是否需要订阅通知，目标对象对此一无所知
        4. 有点像两个模板方法
## 装饰模式 Decorator
* 单一职责模式
    * 如果责任划分不明确，使用继承得到的，结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码这时候的关键是**划清责任**
    * 典型模式
        1. Decorator
        2. Bridge
* 举例子：流操作
    1. 不同流 主体操作，从流继承而来
    2. 缓冲 拓展方向，没有必要从不同的流继承来
    3. 加密 拓展方向，没有必要从不同的流继承来
    4. 上面的组合
* 编译时复用，运行时变换
* 附着在某个基础上的变化
* 既继承又组合，应多主题类多个方向上的功能的组合拓展

