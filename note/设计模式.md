# 设计模式 
##  复用性能 ! 管理稳定和变化！把跳动的小兔子关进笼子
## 1.设计模式简介
* 课程目标   
    * 理解松耦合设计思想  
    * 掌握面向对象设计原则
    * 握重构技法改善设计
    * 掌握GOF核心设计模式 
* 什么是设计模式  
每个模式不断重复的解决方案的核心，不要重复造轮子
* GOF设计模式  
    * 可复用面向对象软件的基础  
    * 目标：可复用
    * 手法：面向对象
* 面向对象谈起  
    * 底层思维：把握机器底层
        * 语言构造
        * 编译转换
        * 内存模型
        * 运行机制：把周围的世界抽象未程序代码
    * 抽象思维：管理代码复杂度
        * 面向对象
        * 组件封装
        * 设计模式
        * 架构模式
    * 程序员：联系现实需求和计算机
* 深入理解面向对象
    * 向下：深入理解面向对象三大机制，内部机制
        * 封装：隐藏内部实现
        * 继承：复用现有代码
        * 多态：改写对象行为
    * 向上： 把握面向对象对象机制带来的抽象意义  
    掌握什么是好多面向对象机智
* 抽象思维的背景，软件设计固有的复杂性
    * 根本原因：变化
        * 客户需求的变化
        * 技术平台的变化
        * 开发团队的变化
        * 市场环境的变化
    * 解决方法
        * 分解：分而治之
        * 抽象：抓住事物的本质特点，处理泛化和理想化的对象模型
            1. 父类指针指向子类对象
            2. 指针vector需要一个堆对象的指针
            3. 虚函数，多态调用的方法
## 2.面向对象设计原则
* 最大优势：抵御变化
* 面向对象
    * 底层：封装，继承，多态等
    * 抽象：
        * 隔离变化
        * 各司其职
        新增类不影响原类型的实现
    * 面向对象设计原则
        1. 依赖倒置原则（DIP）
            1. 高层模块（稳定）不应该依赖低层模块（变化）二者都应依赖于抽象（稳定）
            2. 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）
            3. 变化依赖稳定，不可相逆
            4. 关键点：提出抽象类（例程的shape）
        2. 开放封闭原则（OCP）
            1. 对拓展开放，对更改封闭（增加，而非修改）
            2. 类模块应该是可扩展的，但是不可修改
        3. 单一职责原则（SRP）
            1. 一个类应该仅有一个引起它变化的原因
            2. 变化的方向隐含着类的责任
        4. Liskov 替换原则（LSP）
            1. 子类必须能够替换他们的基类（IS-A）
            2. 继承表达类型抽象 
        5. 接口隔离原则（ISP）
            1. 不应该强迫客户程序依赖它们不用的方法（该protect就protect防止客户依赖性）
            2. 接口应该小而完备
        6. 优先使用对象阻合而不是类继承
            1. 类继承：白箱复用，对象组合：黑箱阻合，class A里面放一个class B这样
            2.  继承在某种程度上破坏了封装性
            3. 对象组合则只要求被组合对象有良好定义的接口
        7. 封装变化点 松耦合
            1. 使用封装来创建对象之间的分界层，让设计者可以在一侧变化的同时保持另一侧稳定
        8. 针对接口编程，而不是针对实现编程
            1. 不将变量类型声明为具体类，而是声明为接口
            2. 客户无需获知对象的具体类型，只需要指导对象具有的接口（抽象）
            3. 依赖接口而不依赖具体类型
            4. 和DIP相辅相成，只是角度不同
    * 接口标准化：产业昌盛的标志  
        1. 箭和弩的接口统一化，避免箭不对弩
        2. 木板字模的大小接口和活字的大小接口，分离
    * 设计原则->设计经验
        1. 设计习语 Design Idioms
            与特定语言相关的低层模式，技巧和惯用法
        2. 设计模式 Design Patterns
            类与接口，变化中的复用性问题
        3. 架构模式 Architectural Patterns
            系统划分，责任和写作关系
## 3.前言
* GOF-23 模式分类  
    *  从目的看来
        1. 创建型：解决对象创建工作
        2. 结构型：变化需求对对象结构的冲击
        3. 行为型：对各类直接的组合和交互的冲击  
    * 从范围，实现手段来看
        1. 类模式处理类和子类的静态关系，继承方案
        2. 对象模式处理对象间动态关系，组合关系
* 重构获得模式 Refactoring to Patterns
    * 好的面向对象设计：应对变化，提供复用
    * 软件特征：需求频繁变化  
        #### 要点：寻求并且在变化点处应用设计模式
    * 敏捷开发提倡的Refactoring to Patterns 是当前最好的
    * 重构：改善现有代码的设计
* 重构关键技法 ->转
    * 静态->动态
    * 早绑定（后调用前）->晚绑定（前调用后，callback函数）
    * 继承->组合
    * 编译时依赖->运行时依赖
    * 紧耦合->松耦合
* 组件协作模式
    * 背景：软件专业化分工划分出 
        1. 框架 framework和library
        2. 应用
    * 组件写作模式通过晚期绑定来实现框架与应用之间的松耦合
    * 二者写作的常用模式 
        1. Template Method 模板方法
        2. Strategy 策略模式
        3. Observer/Event 事件模式
        4. 其他模式也会有关系只是没有那么明显
## 4.模板方法Template method
* 举个栗子：stm32的回调函数
* 动机
    * 每项任务有稳定的整体操作结构
    * 各个子步骤有改变的需求，而无法和任务的同时实现
    * 如何在确定稳定操作结构的前提下灵活应对各个滋补粥的变化或晚期实现需求
* 模式定义
    * 定义一个操作的骨架（稳定），而将一些步骤延迟变化到子类中。模板方法使得子类可以复用一个算法的结构，同时支持子类的变化（虚函数）
* 原则    
    * 前提条件：稳定的算法骨架结构，有变化的需求
    * 稳定中有变化而且互不干扰
    * 稳定的用非虚函数，变化时虚函数
    * 调用机制：虚函数，函数指针建立晚绑定机制
    * 稳定的步骤函数一般protected，单独调用没有意义